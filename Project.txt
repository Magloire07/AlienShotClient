Objectif final du systÃ¨me

Ma tablette reÃ§oit une photo (depuis mon Sony zv-e 10 ).

Un petit service Android dÃ©tecte la photo.

Le service lance automatiquement un pipeline OpenCV + ML Kit :

auto-exposition / auto-level

balance des blancs intelligente

upscale + sharpen (comme â€œAmÃ©liorationâ€ de Google Photos)

dÃ©bruitage

ajustements ambiance / contraste / structure

Le rÃ©sultat final est enregistrÃ© â†’ utilisÃ© ou uploadÃ© automatiquement.

ğŸ—ï¸ Architecture simple du mini-service Android

Tu dÃ©veloppes une petite app (Kotlin), sans interface, qui tourne en arriÃ¨re-plan.

Composants :

FileObserver â†’ dÃ©tecte l'arrivÃ©e d'une nouvelle image.

OpenCV â†’ retouche classique (contraste, sharpen, dÃ©bruitageâ€¦).

ML Kit (Image Enhancement + Segmentation) â†’ amÃ©liorations â€œintelligentesâ€.

Coroutines â†’ pipeline non bloquant.

WorkManager â†’ garantir lâ€™exÃ©cution mÃªme si lâ€™app est en arriÃ¨re-plan.

ğŸ§ª Ã‰tape 1 â€” Installer OpenCV dans ton app Android

Dans ton build.gradle (module) :

dependencies {
    implementation "org.opencv:opencv-android:4.10.0"
}


Initialisation :

OpenCVLoader.initDebug()

ğŸ§  Ã‰tape 2 â€” Ajouter ML Kit Image Enhancement

ML Kit propose plusieurs modÃ¨les utiles (et gratuits, offline) :

Auto White Balance

Auto Exposure

Super Resolution (qualitÃ©)

Face detection (pour appliquer des retouches ciblÃ©es)

Exemple ML Kit :

dependencies {
    implementation("com.google.mlkit:image-segmentation-selfie:16.0.0")
    implementation("com.google.mlkit:vision-common:17.2.0")
}

ğŸ” Ã‰tape 3 â€” DÃ©tection de nouvelle image

Tu surveilles un dossier (/storage/emulated/0/DCIM/Imaging Edge Mobile/) :

val observer = object : FileObserver(watchPath, CREATE) {
    override fun onEvent(event: Int, path: String?) {
        if (event == CREATE && path?.endsWith(".jpg") == true) {
            processImage("$watchPath/$path")
        }
    }
}
observer.startWatching()

ğŸ¨ Ã‰tape 4 â€” Ton pipeline â€œGoogle Photos Likeâ€

Voici un pipeline complet, trÃ¨s proche de lâ€™effet â€œAmÃ©lioration Autoâ€ :

â–¶ï¸ 4.1 â€” Auto-level

OpenCV :

fun autoLevel(src: Mat): Mat {
    val dst = Mat()
    Core.normalize(src, dst, 0.0, 255.0, Core.NORM_MINMAX)
    return dst
}

â–¶ï¸ 4.2 â€” Balance des blancs intelligente

(ML Kit white balance ou une version OpenCV)

fun whiteBalance(src: Mat): Mat {
    val lab = Mat()
    Imgproc.cvtColor(src, lab, Imgproc.COLOR_BGR2Lab)
    val channels = ArrayList<Mat>()
    Core.split(lab, channels)

    // CLAHE sur la luminance â†’ effet â€œambianceâ€ Google Photos
    val clahe = Imgproc.createCLAHE()
    clahe.clipLimit = 2.5
    clahe.apply(channels[0], channels[0])

    Core.merge(channels, lab)
    val result = Mat()
    Imgproc.cvtColor(lab, result, Imgproc.COLOR_Lab2BGR)
    return result
}

â–¶ï¸ 4.3 â€” Denoise / Lissage lÃ©ger
fun denoise(src: Mat): Mat {
    val dst = Mat()
    Photo.fastNlMeansDenoisingColored(src, dst, 5f, 5f, 7, 21)
    return dst
}

â–¶ï¸ 4.4 â€” Sharpen (style â€œStructureâ€ Google Photos)
fun sharpen(src: Mat): Mat {
    val kernel = Mat.ones(3, 3, CvType.CV_32F)
    kernel.put(1, 1, -7.0)
    val dst = Mat()
    Imgproc.filter2D(src, dst, src.depth(), kernel)
    return dst
}

â–¶ï¸ 4.5 â€” Boost de saturation subtil
fun boostSaturation(src: Mat): Mat {
    val hsv = Mat()
    Imgproc.cvtColor(src, hsv, Imgproc.COLOR_BGR2HSV)
    val channels = ArrayList<Mat>()
    Core.split(hsv, channels)
    Core.multiply(channels[1], Scalar(1.10), channels[1]) // +10%
    Core.merge(channels, hsv)
    val dst = Mat()
    Imgproc.cvtColor(hsv, dst, Imgproc.COLOR_HSV2BGR)
    return dst
}

ğŸ Ã‰tape 5 â€” Composition du pipeline

Tout en Kotlin, sans main().

suspend fun processImage(path: String) {
    val src = Imgcodecs.imread(path)

    var img = src
    img = autoLevel(img)
    img = whiteBalance(img)
    img = denoise(img)
    img = sharpen(img)
    img = boostSaturation(img)

    Imgcodecs.imwrite(path.replace(".jpg", "_edited.jpg"), img)
}
